<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<head>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<style>
/*body {
font-family: 'Franklin Gothic Medium','Franklin Gothic', 'ITC Franklin Gothic', Arial, sans-serif;
}*/
line {
  stroke-width:1;
  stroke:rgb(50,50,50);
}
.x-axis path,
.x-axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
    stroke-width:1px;
}

.x-axis text {
    font-family: sans-serif;
    font-size: 9px;
}
.hover-rects {
  pointer-events: all;
}

</style>
</head>
<body>

<div id="main">
    <select id="productSelect">
      <option selected value="Cement Dangote">Cement Dangote</option>
      <option value="Drink Swan Water Bottle">Drink Swan Water Bottle</option>
      <option value="Maize White">Maize White</option>
      <option value="Maize Yellow">Maize Yellow</option>
      <option value="Rice Imported">Rice Imported</option>
      <option value="Rice Local">Rice Local</option>
      <option value="Sorghum">Sorghum</option>
    </select>
    <div id="volChart"></div>
</div>

</body>
<script>


function draw(volatility, volBoxValues, volStateLabels, volZonePosition){ // Calculates the Chart Scales and the Y-Scale for the panel (independent of the product selections)
  //Constructed Functions and variables for the cade
  function uniq_fast(a) { // quickly drop duplicate values from an array
      var seen = {};
      var out = [];
      var len = a.length;
      var j = 0;
      for(var i = 0; i < len; i++) {
           var item = a[i];
           if(seen[item] !== 1) {
                 seen[item] = 1;
                 out[j++] = item;
           }
      }
      return out;
  }
  function filterData(data, input){ //generic funciton to filter data based on an input
  return data.filter(function(d) {return d.item === input})
  }
  var monthYear = d3.time.format("%b %y"); //converts to Month-Year
  var monthFormat = d3.time.format("%Y-%m").parse; //Parse dates and converts to a d3 time format
  var monthFormatToString = d3.time.format("%Y-%m")




  var sel = document.getElementById('productSelect');
  var product = sel.options[sel.selectedIndex].value;
  var data = filterData(volatility, product); //loading the volatility data based on input

  var zoneData = filterData(volBoxValues, product); //loading the zones data based on the input


  //Calculating Domains
  var xChartDomain = uniq_fast(volatility.map(function(d){return monthFormat(d.date.slice(0,7))})).sort(function(a,b) { return a - b;});//the width of chart is based on the number of dates.
  var maxYPosition = d3.max(volStateLabels, function(d){return d.yPosition})
  var yPanelDomain = [] //the states within each panel are positioned using this domain with a stagger for each zone added
  for(i = 1; i <= maxYPosition; i++){
    yPanelDomain.push(i)
  }
  var xPanelDomain = [0, Math.ceil(d3.max(volatility, function(d){return d.volMoving})/10)*10]; // the width of each panel is set to the range of volatility for the selected input
  var colorDomain = xPanelDomain //the color domain is set to the range of volatility values
console.log(data)
  function mouseover(d){
    console.log(d)
    xChartDomain.forEach(function(e){
      var centers = data.filter(function(f){ return f.state===d.state && monthFormatToString(e) === f.date.slice(0,7)})
      var mean = d3.mean(centers, function(g){return g.volMoving})
      console.log(mean)
    })

  }

  //Creating the canvas
  var containerSize = {'height': 600, 'width': 1000}
  var containerMargin = {top: 0.02 * containerSize.height , right: 0.01 * containerSize.width, bottom: 0.02 * containerSize.height, left: 100} //controls the spacing between the edge of the container and the inner chart
  var containerPadding = {top: 0.06 * containerSize.height, right: 0.006 * containerSize.width, bottom: 0.06 * containerSize.height, left: 0.01 * containerSize.width} //controls the size of the chart
  var chartSize = {'height': containerSize.height - containerMargin.top - containerMargin.bottom, 'width': containerSize.width - containerMargin.right - containerMargin.left}
  var width = chartSize.width - containerPadding.left - containerPadding.right
  var height = chartSize.height - containerPadding.top - containerPadding.bottom

  var volChart = d3.select('#volChart').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: containerSize.height,
          width: containerSize.width
        })
      .append('g')
      .attr("transform", "translate(" + containerMargin.left + "," + containerMargin.top + ")");

  var xChartScale = d3.scale.ordinal()
      .domain(xChartDomain)
      .rangeRoundBands([containerPadding.left, width+containerPadding.left], .1)

  var panelWidth = containerPadding.right+xChartScale.rangeBand()
  //console.log(panelWidth)

  var yPanelScale = d3.scale.ordinal()
      .domain(yPanelDomain)
      .rangeBands([containerPadding.top, containerPadding.top+height], 0.2)

  var xPanelScale = d3.scale.linear()
      .domain(xPanelDomain)
      .range([containerPadding.right, panelWidth])

  var xAxis = d3.svg.axis()
      .scale(xPanelScale)
      .orient("bottom")
      .tickSize(7)
      .ticks(4)
      .tickPadding(8)

  var colorScales = d3.scale.linear() //could change the scale later
        .domain(colorDomain) //based on the maximum volatility value in the data (better than just binning)
        .range(["#0000ff","#ff0000"])
        .interpolate(d3.interpolateHcl);

  var stateFont = 10
  var bigFont = 16
  //Drawing the chart
  volChart.append('g') //vertical panels
      .selectAll(".vboxes")
      .data(xChartDomain)
      .enter()
      .append('rect')
      .attr({
        x: function(d){return xChartScale(d)},
        y: 20,
        height: height + 20,
        width: panelWidth
      })
      .style("stroke", "none")
      .style("fill", "rgb(252,255,252)");

  volChart.append('g') //zonal labels
      .attr('class', 'y-labels')
      .selectAll('text')
      .data(volZonePosition)
      .enter()
      .append('text')
      .text(function(d){return ('Z'+d.zoneCode)})
      .attr({
        x: -80,
        y: function(d){return (yPanelScale(Math.floor(d.position)) + yPanelScale(Math.ceil(d.position)))/2}
      })
      .style('font-size', bigFont)
      .style('alignment-baseline', 'central')
      .style('text-anchor', 'start')
      .style('cursor', 'default')

  volChart.append('g') //date labels
      .attr('class', 'x-labels')
      .selectAll('text')
      .data(xChartDomain)
      .enter()
      .append('text')
      .text(function(d){return monthYear(d)})
      .attr({
        x: function(d){return xChartScale(d) + panelWidth/2},
        y: 20
      })
      .style('font-size', bigFont)
      .style('alignment-baseline', 'central')
      .style('text-anchor', 'middle')
      .style('cursor', 'default');

  volChart.append('g') //state labels
      .attr('class', "state-labels")
      .selectAll('text')
      .data(volStateLabels)
      .enter()
      .append('text')
      .text(function(d){return d.state})
      .attr({
        x: 10,
        y: function(d){return yPanelScale(d.yPosition)}
      })
      .style('font-size', stateFont)
      .style('alignment-baseline', 'central')
      .style('text-anchor', 'end')
      .style('cursor', 'default');

  var meanLine = volChart.append('g') //mean
      .selectAll(".boxLines")
      .data(zoneData)
      .enter()
      .append('line')
      .attr({
        x1: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
        y1: function(d) {return yPanelScale(d.minY)},
        x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
        y2: function(d){return yPanelScale(d.maxY)}
      })
  // volChart.append('g') //left-top
  //     .selectAll(".boxLines")
  //     .data(zoneData)
  //     .enter()
  //     .append('line')
  //     .attr({
  //       x1: function(d){return (xPanelScale(d.mean) + xChartScale(d.date)) - 3},
  //       y1: function(d) {return yPanelScale(d.minY) - 3},
  //       x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
  //       y2: function(d){return yPanelScale(d.minY)}
  //     })
  // volChart.append('g') //right-top
  //     .selectAll(".boxLines")
  //     .data(zoneData)
  //     .enter()
  //     .append('line')
  //     .attr({
  //       x1: function(d){return (xPanelScale(d.mean) + xChartScale(d.date)) + 3},
  //       y1: function(d) {return yPanelScale(d.minY) - 3},
  //       x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
  //       y2: function(d){return yPanelScale(d.minY)}
  //     })
  // volChart.append('g') //bottom-left
  //     .selectAll(".boxLines")
  //     .data(zoneData)
  //     .enter()
  //     .append('line')
  //     .attr({
  //       x1: function(d){return (xPanelScale(d.mean) + xChartScale(d.date)) - 3},
  //       y1: function(d) {return yPanelScale(d.maxY) + 3},
  //       x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
  //       y2: function(d){return yPanelScale(d.maxY)}
  //     })
  // volChart.append('g') //bottom-right
  //     .selectAll(".boxLines")
  //     .data(zoneData)
  //     .enter()
  //     .append('line')
  //     .attr({
  //       x1: function(d){return (xPanelScale(d.mean) + xChartScale(d.date)) + 3},
  //       y1: function(d) {return yPanelScale(d.maxY) + 3},
  //       x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
  //       y2: function(d){return yPanelScale(d.maxY)}
  //     })

  var rects = volChart
      .selectAll('.hover-rects')
      .data(volStateLabels)
      .enter()
      .append('rect')
      .attr({
        x: -36,
        y:function(d){return yPanelScale(d.yPosition) - stateFont/2},
        height: stateFont,
        width: (width+containerPadding.left + 36),
        class: 'hover-rects'
      })
      .style('fill', 'none')
      .on('mouseover', mouseover)


  var dots = volChart.append('g') //the circles
      .selectAll('.dots')
      .data(data).enter()
      .append('circle')
      .attr({
        r: 2,
        cx: function(d){return xChartScale(d.date) + xPanelScale(d.volMoving)},
        cy: function(d){return yPanelScale(d.yPosition)}
      })
      .style({
          fill: function(d){return colorScales(d.volMoving)}
        })
      
  
  var axisNodes = volChart.append('g') //Adding the axis
      .attr('class', 'x-axis')
      .attr("transform", "translate(" + (2*containerPadding.left) + ","+ (height + 40) + ")")
      .call(xAxis)


  
  d3.select('#productSelect')
    .on('change', function(d) {
        var product = d3.select(this).property('value')
        redraw(product)
    })


  function redraw(product){ //recalibrates the x-PanelScale and redraws the means and dots based on the product selection
    var data = filterData(volatility, product); //loading the volatility data based on input
    var zoneData = filterData(volBoxValues, product); //loading the zones data based on the input

    var colorDomain = xPanelDomain //updating the color domain

    dots = dots.data(data);
    dots.exit().remove();
    dots.enter().append('circle');
    dots.attr({
        r: 2,
        cx: function(d){return xChartScale(d.date) + xPanelScale(d.volMoving)},
        cy: function(d){return yPanelScale(d.yPosition)}
      })
      .style({
          fill: function(d){return colorScales(d.volMoving)}
        })
    meanLine = meanLine.data(zoneData)
    meanLine.exit().remove()
    meanLine.enter().append('line');
    meanLine.attr({
      x1: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
      y1: function(d) {return yPanelScale(d.minY)},
      x2: function(d){return xPanelScale(d.mean) + xChartScale(d.date)},
      y2: function(d){return yPanelScale(d.maxY)}
    })
  }
}






queue()
  .defer(d3.json, "data/volatility.json")
  .defer(d3.json, "data/volBoxValues.json")
  .defer(d3.json, "data/volStateLabels.json")
  .defer(d3.json, "data/volZonePosition.json")
  .await(ready);



function ready(error, volatility, volBoxValues, volStateLabels, volZonePosition){
  
  draw(volatility, volBoxValues, volStateLabels, volZonePosition);

}

//queing the data file




</script>
</html>