<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<head>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<style>

</style>
</head>
<body>

<div id="main">
	<div id="mapContainer"></div>
	<div id="lineChartContainer"></div>
</div>

</body>
<script>


var drawMap = function(states_map, data_to_map) {

	/* DEFINE CONSTANTS */
	var mapContainerSize = {'height':800,'width':800};
	var mapSize = {'height':800,'width':800};

	/* CREATE THE MAP SVG CONTAINERS */
	var mapContainer = d3.select("#mapContainer").append("svg")
		.attr("width", mapContainerSize.width)
        .attr("height", mapContainerSize.height);

	var map = mapContainer.append("g")
        .attr("width", mapSize.width)
        .attr("height", mapSize.height);

    /* CREATE THE DATA LOOKUP FOR THE MAP */
    var data_lookup = {};
    data_to_map.forEach(function(d) {
    	data_lookup[d.name] = d.value;
    });

	/* DEFINE COLOR SCALES AND BINS */
    var color = d3.scale.threshold().domain([]).range([]);
    var colorArray = ['rgb(189,0,38)','rgb(240,59,32)','rgb(253,141,60)','rgb(254,178,76)','rgb(254,217,118)']; // change these as we like for different color schemes
    var max = 100; // we'll want to get this from the data
    var bounds = [];
	for (var i=1;i<=5;i++) {
		bounds.push((max*1.05)*(i/5));
	}
	var y = d3.scale.linear().domain([]).range([118, 0]); // 118 is the height in pixels of the legend
    y.domain([0, max*1.05]);
    var xAxis = d3.svg.axis().scale(y).orient("right").tickSize(10);
    xAxis.tickValues([0].concat(bounds));
    color.domain(bounds).range(colorArray); 

    var key = mapContainer.append("g")
        .attr("class", "key")
        .attr("transform", "translate(263,278)"); // will need to change the translation coordinates

    key.selectAll("rect")
        .data(color.range().map(function(d, i) {
          return {
            x0: i ? y(color.domain()[i - 1]) : y.range()[0],
            x1: i < color.domain().length ? y(color.domain()[i]) : y.range()[1],
            z: d
          };
        }))
        .enter().append("rect")
        .attr("height", function(d,i) { return d.x0 - d.x1})
        .attr("y", function(d, i) { return d.x1; })
        .attr("width", 6)
        .style("fill", function(d) { return d.z; });

	var projection = d3.geo.mercator()
		.center([0, 0])
		.scale(1500)
		.translate([mapSize.width / 2, mapSize.height / 2]);

	var path = d3.geo.path().projection(projection);

	states = map.selectAll('.states')
  	.data(topojson.feature(states_map, states_map.objects.NGA_adm1).features)
  	.enter().append("path")
  	.attr('d', path)
  	.style("fill", function(d, i) {
  		console.log(d.properties.NAME_1); // this is the name property for the map features
  		if (data_to_map.filter(function(e) { return e.name===d.properties.NAME_1})[0]===undefined) {
  			return 'rgb(200,200,200'; // return gray fill for states without data
  		}
  		else {
  			return color(data_to_map.filter(function(e) { return e.name===d.properties.NAME_1})[0]['value']); // otherwise pass the data value of the given state to the color function
  		}
    })
  	.attr('class','states');
};

var drawLineChart = function(data) {

	/* ALL LINE CHART-RELATED CODE AND FUNCTIONS WILL GO IN HERE*/

};

/* THESE FUNCTIONS GET CALLED BY THE QUEUE AND RETURN THE CORRECTLY STRUCTURED DATA ON LOAD. THEY WILL EVENTUALLY BE REPLACED BY SERVER-SIDE DATA API'S */
function processData1(d) {}
function processData2(d) {}

/* THE QUEUE SPECIFIES WHICH DATASETS TO LOAD. IT WILL EVENTUALLY BE REPLACED BY CALLS TO A DATA API (EXCEPT IN THE CASE OF STATIC MAP FILES) */
queue()
	.defer(d3.json, "maps/nga-states-topo-05.json")
	.defer(d3.csv, "maps/data_to_map.csv")
	.await(ready);

/* WHEN ALL THE DATASETS IN THE QUEUE ARE LOADED UP THE ready FUNCTION IS TRIGGERED */
function ready(error, states_map, data_to_map) {
	/* PASS THE PROCESSED DATA TO THE CHARTING FUNCTIONS */
	drawMap(states_map, data_to_map);

}

</script>
</html>