<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<head>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<style>

</style>
</head>
<body>

<div id="main">
	<div id="segChart"></div>
</div>

</body>
<script>

//Constructed Functions and variables for the cade
function uniq_fast(a) { // quickly drop duplicate values from an array
      var seen = {};
      var out = [];
      var len = a.length;
      var j = 0;
      for(var i = 0; i < len; i++) {
           var item = a[i];
           if(seen[item] !== 1) {
                 seen[item] = 1;
                 out[j++] = item;
           }
      }
      return out;
  }
//loading the data
queue()
  .defer(d3.json, "data/passthrough.json") //the  main dataset
  .defer(d3.json, "data/passZoneLabels.json") //the dataset for first layer of x-labels for zones
  .defer(d3.json, "data/passItemLabels.json") //the dataset for item labels
  .await(ready);

function ready(error, passthrough, passZoneLabels, passItemLabels) {
  var maxPosition = d3.max(passthrough, function(d){return d.dotPosition});
  var xDomain = [] // creating the x-axis domain for the chart (a series of dots)
  for (i = 1; i <= maxPosition; i++){
    xDomain.push(i)
  };
  var yDomain = d3.extent(passthrough, function(d){return d.pT}); // the domain of the y-axis is set to the range of passthrough values
  var colorDomain = yDomain; //same with the color scale

  //creating the canvas
  var containerSize = {'height': 200, 'width': 400}
  var containerMargin = {top: 0.02 * containerSize.height , right: 0.01 * containerSize.width, bottom: 0.2 * containerSize.height, left: 0.01 * containerSize.width} //controls the spacing between the edge of the container and the inner chart
  var containerPadding = {top: 0.06 * containerSize.height, right: 0.006 * containerSize.width, bottom: 0.06 * containerSize.height, left: 0.01 * containerSize.width} //controls the size of the chart
  var chartSize = {'height': containerSize.height - containerMargin.top - containerMargin.bottom, 'width': containerSize.width - containerMargin.right - containerMargin.left}
  var width = chartSize.width - containerPadding.left - containerPadding.right
  var height = chartSize.height - containerPadding.top - containerPadding.bottom
  var segChart = d3.select('#segChart').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: containerSize.height,
          width: containerSize.width
        })
      .append('g')
      .attr("transform", "translate(" + containerMargin.left + "," + containerMargin.top + ")");

  var xScale = d3.scale.ordinal() //the ordinal scale uses dotpositions to place them on charts
      .domain(xDomain)
      .rangeRoundBands([containerPadding.left, width+containerPadding.left], .1)

      console.log(xDomain)

  var yScale = d3.scale.linear() //set to the range of passthrough values
      .domain(yDomain)
      .range([containerPadding.top, containerPadding.top+height])

  var colorScale = d3.scale.linear() //could change the scale later
      .domain(colorDomain) //based on the maximum volatility value in the data (better than just binning)
      .range(["#0000ff","#ff0000"])
      .interpolate(d3.interpolateHcl);
  var zoneNameGap = 30
  var itemNameGap = 10 + zoneNameGap
  var itemNamestagger = 10
  //drawing
  segChart.append('g')
      .selectAll('.dots')
      .data(passthrough)
      .enter()
      .append('circle')
      .attr({
        r: 2,
        // cx: function(d){return xScale(d.dotPosition) + (d.boxPosition - 1) * 10},
        cx: function(d){return xScale(d.dotPosition)},
        cy: function(d){return yScale(d.pT)}
      })
      .style({
          fill: function(d){return colorScale(d.pT)}
        })

  segChart.append('g')
      .attr('class', 'zone-labels') //corresponding to each column of dots
      .selectAll('text')
      .data(passZoneLabels)
      .enter()
      .append('text')
      .text(function(d){return d.zoneCode})
      .attr({
        x: function(d) {return xScale(d.dotPosition)},
        y: height + zoneNameGap
      })
      .style('text-anchor', 'middle')
      .style('font-size', 10)

  segChart.append('g')
      .attr('class', 'item-labels')
      .selectAll('text')
      .data(passItemLabels)
      .enter()
      .append('text')
      .text(function(d){return d.item})
      .attr({
        x: function(d){return (xScale(Math.floor(d.xPosition)) + xScale(Math.ceil(d.xPosition)))/2 },
        y: function(d){return height + itemNameGap + itemNamestagger*d.yPosition} //yPosition is a 0-1 variable
      })
      .style('text-anchor', 'middle')
      .style('font-size', 10)
}

</script>
</html>