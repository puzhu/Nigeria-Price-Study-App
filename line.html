<!DOCTYPE html>
<html>

<meta charset="utf-8">

<head>
<title>Line Magic</title>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<style>
.voronoi path {
  fill: none;
  stroke:none;
  pointer-events: all;
}
</style>
</head>

<body>
<div id="main">
	<div id="mapContainer"></div>
	<div id="lineChartContainer"></div>
</div>
</body>

<script>
var monthFormatChart = d3.time.format("%m/%y");
var dateFormat = d3.time.format("%Y-%m-%d");

function uniq_fast(a) { // quickly drop duplicate values from an array
    var seen = {};
    var out = [];
    var len = a.length;
    var j = 0;
    for(var i = 0; i < len; i++) {
         var item = a[i];
         if(seen[item] !== 1) {
               seen[item] = 1;
               out[j++] = item;
         }
    }
    return out;
}

function deString(d) {
	if (d==="") { 
		return NaN;
	} else {
		return +d;
	}
}

function processPrices(d, i) {
	var state = {
		state: d.state,
		price: deString(d.meanPrice),
		item: d.item,
		date: dateFormat.parse(d.date),
		weight: deString(d.weight)
	};
	return state;
}

queue()
	.defer(d3.csv, "data/priceStateData.csv", processPrices)
	.await(ready);

function ready(error,priceData) {

	var product = "Cement Dangote";
	priceData = priceData.filter(function(d) { return d.item===product});
	var months = uniq_fast(priceData.map(function(d){ return d.date})).sort(function(a,b) { return a - b;});

	var lineData = reshapeMonthlyPrice(priceData);

	var lineContainerSize = {'width': 800, 'height': 400};
	var lineChartSize = {'width': 800, 'height': 400};
	var margin = {top: 7, right: 5, bottom: 25, left: 35};
	var w = lineChartSize.width - margin.right - margin.left;
	var h = lineChartSize.height - margin.top - margin.bottom;
	
	//Creating the canvas
	var lineContainer = d3.select('#lineChartContainer').append('svg')
						.attr({
							width: lineContainerSize.width,
							height: lineContainerSize.height
						});
	var lineChart = lineContainer.append('g')
					.attr({
						width: w,
						height: h,
						transform: "translate(" + margin.left + "," + margin.top + ")"
					});

	lineChart.append("clipPath")
		.attr('id', 'lineclip')
		.append('rect')
		.attr("x", 0)
		.attr("width", w)
		.attr("y", 0)
		.attr("height", h);

	//Defining charting variables
	var xScale = d3.time.scale()
				.domain(d3.extent(months))
				.range([0, w]);
	var yScale = d3.scale.linear()
				.domain([0, d3.max(priceData.map(function(d) { return d.price; }))*1.05])
				.range([h, 0]);

	// var yAxis = d3.svg.axis()
	// 			.scale(yScale)
	// 			.orient('left')

    var line = d3.svg.line()
    .defined(function(d) { return (d !== null && !isNaN(d.price)); })
    .x(function(d) { return xScale(d.month); })
    .y(function(d) { return yScale(d.price); });

	var xAxis = d3.svg.axis()
        .scale(xScale)
        .tickSize(7)
        .ticks(6)
        .tickFormat(function(d, i) {
            return monthFormatChart(d);
        })
        .tickPadding(8)
        .orient('bottom');

    var xAxisNodes = lineChart.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + h + ")")
          .style("shape-rendering", "crispEdges")
          .style("font-size", "10px")
          .call(xAxis);

    d3.selectAll(".x.axis path").style("display","none");
    xAxisNodes.selectAll("line")
        .style("stroke", function(d,i) {
            return "black";
        });

    xAxisNodes.selectAll("text").style('font-family','Helvetica Neue').style('font-size',"12px");

	var yAxis = d3.svg.axis()
        .scale(yScale).ticks(5)
        .orient("left")
        .tickSize(-w)
        .tickPadding(6)
        .tickFormat(function(d) { return d});

    var g = lineChart.append("g")
        .attr("class", "y axis")
        .style("font-size", "10px")
        .call(yAxis)
        .style("shape-rendering", "crispEdges");

    d3.selectAll(".y.axis path").style("display","none").style("stroke","lightgrey").style("stroke-width","1px");
    d3.selectAll(".y.axis line").style("stroke","lightgrey").style("stroke-width","1px");

    d3.selectAll(".y.axis text").style('font-family','Helvetica Neue').style('font-size',"12px");


	lineChart.append("g")
	.attr("class", "stateLines")
	.selectAll("path")
	.data(lineData)
	.enter().append("path")
	.attr("d", function(d) { d.line = this; return line(d.values); })
	.attr("clip-path", 'url(#lineclip)')
	.style("fill","none")
    .style("stroke-width","1px")
    .style("stroke",function(d,i) { 
		return "#4D4D4D"
    });

    console.log(d3.nest()
	          .key(function(d) { return xScale(d.month) + "," + yScale(d.price); })
	          .rollup(function(v) { return v[0]; })
	          .entries(d3.merge(lineData.map(function(d) { return d.values; })))
	          .map(function(d) { return d.values; }))
	var voronoi = d3.geom.voronoi()
	    .x(function(d) { return xScale(d.month); })
	    .y(function(d) { return yScale(d.price); })
	    .clipExtent([[0, 0], [w, h]]);

	  var voronoiGroup = lineChart.append("g")
	      .attr("class", "voronoi");

	  voronoiGroup.selectAll("path")
	      .data(voronoi(d3.nest()
	          .key(function(d) { return xScale(d.month) + "," + yScale(d.price); })
	          .rollup(function(v) { return v[0]; })
	          .entries(d3.merge(lineData.map(function(d) { return d.values; })))
	          .map(function(d) { return d.values; })))
	    .enter().append("path")
	      .attr("d", function(d) { return "M" + d.join("L") + "Z"; })
	      .datum(function(d) { return d.point; })
	      .style("cursor","default")
	      // .on("mouseover", mouseover)
	      // .on("mouseout", mouseout);

	function reshapeMonthlyPrice(monthlyPrice) {
		var mainArray = [];
		for (var i=0;i<monthlyPrice.length;i++) {
			if (mainArray.filter(function(d) {return d.state===monthlyPrice[i].state}).length===0) { // does the state have its own list item yet?
				var state = {
					state:monthlyPrice[i].state,
					values: [{
						state:monthlyPrice[i].state,
						month:monthlyPrice[i].date,
						price:deString(monthlyPrice[i].price)
					}]
				};
				mainArray.push(state);
			} else {
				var values = {
					state:monthlyPrice[i].state,
					month:monthlyPrice[i].date,
					price:deString(monthlyPrice[i].price)
				};
				mainArray.filter(function(d) {return d.state===monthlyPrice[i].state})[0].values.push(values);

			}
		}
		for (var i=0;i<mainArray.length;i++) {
			mainArray[i].values.sort(function(a,b) {return a.month - b.month;}) // for every state sort the values array by month, ascending
		}
		return mainArray;
	}
	function centerToStates(priceData,item) {
		var array= []
		var states = uniq_fast(priceData.map(function(d) {return d.state}))
		states.forEach(function(d) {
			var stateData = priceData.filter(function(e) {return e.state===d && e.item===item});
			var meanPrice = NaN;
			var weightTotal = NaN;

			stateData.forEach(function(e) {
				if (isNaN(meanPrice) && !isNaN(e.price)) {
					meanPrice = e.price*e.weight;
				}
				else if (!isNaN(meanPrice) && !isNaN(e.price)) {
					meanPrice += e.price*e.weight;
				}

				if (isNaN(weightTotal) && !isNaN(e.weight)) {
					weightTotal = e.weight;
				}
				else if (!isNaN(weightTotal) && !isNaN(e.weight)) {
					weightTotal += e.weight;
				}
			});

			meanPrice = (meanPrice/weightTotal);
			array.push({'state':d,'price':meanPrice})
		});
		return array;
	}
	


}



</script>
</html>
